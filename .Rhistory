var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
T0
x=0
x++
0
x+=1
x=x+1
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
score = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
T0[count,futurestate] = T0[count,futurestate] + 1
}}}}
T0
}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("cartpole50.csv")
source("csvfunction.R")
df = CreateSym(df)
summary(df)
Splitstate = 10
summary(df)
# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("cartpole50.csv")
source("csvfunction.R")
df = CreateSym(df)
summary(df)
Splitstate = 10
summary(df)
# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("cartpole50.csv")
source("csvfunction.R")
df = CreateSym(df)
summary(df)
Splitstate = 10
summary(df)
# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
df
df = read.csv("DATA/data.csv")[,-1]
df = read.csv("DATA/data.csv")[,-1]
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("DATA/data.csv")[,-1]
# df = read.csv("cartpole50.csv")
# source("csvfunction.R")
# df = CreateSym(df)
summary(df)
Splitstate = 10
summary(df)
# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
score = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
T0[count,futurestate] = T0[count,futurestate] + 1
}}}}
T0
}
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
score = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
T0[count,futurestate] = T0[count,futurestate] + 1
}}}}
}
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
score = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
T0[count,futurestate] = T0[count,futurestate] + 1
}}}}
count
}
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
info = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
info[count] = futurestate
}}}}
info
}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("DATA/data.csv")[,-1]
# df = read.csv("cartpole50.csv")
# source("csvfunction.R")
# df = CreateSym(df)
summary(df)
Splitstate = 10
summary(df)
# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:20000, 1)
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
i=sum(CartPosQuantile[1:level] >= CartPos)
if(i==0){i=1}
j=sum(CartVelQuantile[1:level] >= CartVel)
if(j==0){j=1}
k=sum(PoleAngleQuantile[1:level] >= PoleAng)
if(k==0){k=1}
l=sum(PoleVelocityQuantile[1:level] >= PoleVel)
if(l==0){l=1}
return(((i-1) + level*(j-1) + level*level*(k-1) +level*level*level*(l-1))+1)
}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
registerDoParallel(cores=detectCores())
# TOtal state space
totalstate = Splitstate^4
T0 = matrix(0,totalstate,totalstate)
# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:%
#   foreach (i= 1:Splitstate,.combine = 'c') %:%
#   foreach (j= 1:Splitstate,.combine = 'c') %:%
#   foreach (k= 1:Splitstate,.combine = 'c') %:%
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
#
#   }
info = rep(0,totalstate)
Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
count = 0
for (i in 1:Splitstate){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
# %:%
# foreach (i= 1:Splitstate,.combine = 'c') %:%
# foreach (j= 1:Splitstate,.combine = 'c') %:%
# foreach (k= 1:Splitstate,.combine = 'c') %:%
# foreach (l= 1:Splitstate,.combine = 'c') %dopar%
count = count+1
start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
futurestate = var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
info[count] = futurestate
}}}}
info
}
registerDoParallel(cores=detectCores())
registerDoParallel(cores=detectCores())
detectCores()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
registerDoParallel(cores=1)
stopImplicitCluster()
detectCores()

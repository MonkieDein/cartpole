CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Combined_score <- foreach (i= 1:n,.combine = c) %dopar% {
# score = rep(0,5)
for (i in 1:n){
j=1
for (i2 in 1:5){
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
#Update state
run = TRUE
while (run){
if (sum(Combined_B[i,]*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
run=FALSE
}
}
# Save the final score in combined score
# score[i2] = step
Combined_score[i,i2] = step
}
score
}
)
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Combined_score <- foreach (i= 1:n,.combine = c) %dopar% {
# score = rep(0,5)
for (i in 1:n){
j=1
for (i2 in 1:5){
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
#Update state
run = TRUE
while (run){
if (sum(Combined_B[i,]*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
run=FALSE
}
}
# Save the final score in combined score
# score[i2] = step
Combined_score[i,i2] = step
}
# score
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = c) %dopar% {
score = rep(0,5)
# for (i in 1:n){
j=1
for (i2 in 1:5){
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
#Update state
run = TRUE
while (run){
if (sum(Combined_B[i,]*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
run=FALSE
}
}
# Save the final score in combined score
score[i2] = step
# Combined_score[i,i2] = step
}
score
}
)
Combined_B[i,]*state[1:4]
sum(Combined_B[i,]*state[1:4])
sum(Combined_B[i,]*state[1:4])<0
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:% {
# for (i in 1:n){
# for (i2 in 1:5){
foreach (i= 1:n,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
}
)
play <- function(i,i2,init,B,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:19000, 1)
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
while (TRUE){
if (sum(B*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
return(step)
}
}
}
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:% {
# for (i in 1:n){
# for (i2 in 1:5){
foreach (i= 1:n,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
}
)
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:%
foreach (i= 1:n,.combine = 'c') %dopar% {
# for (i in 1:n){
# for (i2 in 1:5){
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
Combined_score
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:%
foreach (i= 1:n,.combine = 'c') %dopar% {
# for (i in 1:n){
# for (i2 in 1:5){
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
list.of.packages <- c("splines", "devtools", "shinystan", "rstan", "lmerTest","gdata","foreach","rlist","doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(splines)
library(devtools)
library(shinystan)
library(rstan)
library(lmerTest)
library(gdata)
library(rlist)
library(foreach) # For parallel programming purposes
library(doParallel)
rm(list = ls())
setwd("~/Desktop/GITHUB/cartpole/cartpole")
# realdf = read.csv("cartpole.csv")
df = read.csv("DATA/data.csv")[,-1]
cn = c("Step" ,"CartPos", "CartVelocity" ,"PoleAngle", "PoleVelocity" ,"Action", "Reward","FutCarPos","FutCarVel", "FutPolAng" ,"FutPolVel","ChgCarPos","ChgCarVel","ChgPolAng","ChgPolVel" )
# SET CONSTANT
n=1000000
POS = 2
CVEL = 3
ANG = 4
PVEL = 5
# MAKE HISTOGRAM TO OBSERVE DISTRIBUTION
for (i in 2:5){
hist(df[which(df$Step==0 & df[,i]>0),i],main=paste("Initial",colnames(df)[i]),nclass=30)
}
# Observe data distribution
pairs(df[which(df$Step==0),2:5])
# Create intial state distribution
bool = matrix(sample(c(1,-1),n*3,replace = TRUE),n,3)
bool = cbind(bool,-bool[,2])
init ={}
for (i in 2:5){
init = cbind(init,runif(n, min = min(df[which(df$Step==0 & df[,i]>0),i]), max = max(df[which(df$Step==0 & df[,i]>0),i])))
}
init = init * bool
colnames(init) = colnames(df)[2:5]
#COMPARE GENERATED INITIAL DISTRIBUTION AND INITIAL DISTRIBUTION
# pairs(init)
# pairs(df[which(df$Step==0),2:5])
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
play <- function(i,i2,init,B,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:19000, 1)
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
while (TRUE){
if (sum(B*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
return(step)
}
}
}
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:%
foreach (i= 1:n,.combine = 'c') %dopar% {
# for (i in 1:n){
# for (i2 in 1:5){
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
)
list.of.packages <- c("splines", "devtools", "shinystan", "rstan", "lmerTest","gdata","foreach","rlist","doParallel")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages)
library(splines)
library(devtools)
library(shinystan)
library(rstan)
library(lmerTest)
library(gdata)
library(rlist)
library(foreach) # For parallel programming purposes
library(doParallel)
rm(list = ls())
setwd("~/Desktop/GITHUB/cartpole/cartpole")
# realdf = read.csv("cartpole.csv")
df = read.csv("DATA/data.csv")[,-1]
cn = c("Step" ,"CartPos", "CartVelocity" ,"PoleAngle", "PoleVelocity" ,"Action", "Reward","FutCarPos","FutCarVel", "FutPolAng" ,"FutPolVel","ChgCarPos","ChgCarVel","ChgPolAng","ChgPolVel" )
# SET CONSTANT
n=1000000
POS = 2
CVEL = 3
ANG = 4
PVEL = 5
# MAKE HISTOGRAM TO OBSERVE DISTRIBUTION
for (i in 2:5){
hist(df[which(df$Step==0 & df[,i]>0),i],main=paste("Initial",colnames(df)[i]),nclass=30)
}
# Observe data distribution
pairs(df[which(df$Step==0),2:5])
# Create intial state distribution
bool = matrix(sample(c(1,-1),n*3,replace = TRUE),n,3)
bool = cbind(bool,-bool[,2])
init ={}
for (i in 2:5){
init = cbind(init,runif(n, min = min(df[which(df$Step==0 & df[,i]>0),i]), max = max(df[which(df$Step==0 & df[,i]>0),i])))
}
init = init * bool
colnames(init) = colnames(df)[2:5]
#COMPARE GENERATED INITIAL DISTRIBUTION AND INITIAL DISTRIBUTION
# pairs(init)
# pairs(df[which(df$Step==0),2:5])
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
play <- function(i,i2,init,B,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
j = sample(1:19000, 1)
step = 1
state = matrix(c(init[(i-1)*5+i2,],1))
while (TRUE){
if (sum(B*state[1:4])<0){
state[1] = state[1] + sum(ChgCarPos0[j,] * state )
state[2] = state[2] + sum(ChgCarVel0[j,] * state )
state[3] = state[3] + sum(ChgPolAng0[j,] * state )
state[4] = state[4] + sum(ChgPolVel0[j,] * state )
} else {
state[1] = state[1] + sum(ChgCarPos1[j,] * state )
state[2] = state[2] + sum(ChgCarVel1[j,] * state )
state[3] = state[3] + sum(ChgPolAng1[j,] * state )
state[4] = state[4] + sum(ChgPolVel1[j,] * state )
}
j=j + 1
step = step+1
#If exceed some angle then we done.
if ((state[3]>CondtionAngle) || (state[3]<(-CondtionAngle))){
return(step)
}
}
}
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:%
foreach (i2= 1:n,.combine = 'c') %dopar% {
# for (i in 1:n){
# for (i2 in 1:5){
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
# Save the final score in combined score
# Combined_score[i,i2] = step
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
Combined_score
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Save the final score in combined score
Combined_score <- foreach (i= 1:n,.combine = 'cbind') %:%
foreach (i2= 1:5,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
Combined_B
Combined_score
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Save the final score in combined score
Combined_score <- foreach (i= 1:n,.combine = 'rbind') %:%
foreach (i2= 1:5,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
}
)
registerDoParallel(cores=1)
stopImplicitCluster()
Best= which(rowMeans(Combined_score)==max(rowMeans(Combined_score)))
Combined_B[Best,]
Combined_score
Best
Combined_B[Best,]
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=1000
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Save the final score in combined score
Combined_score <- foreach (i= 1:n,.combine = 'rbind') %:%
foreach (i2= 1:5,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
}
)
# Make condition Angle, since we are not really sure what is the condition angle, we use a slight conservative angle where is 0.96 of the angle we have seen considered lose.
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
n=10
# Make a matrix that cobined all the score
# Combined_score = matrix(0,n,5)
# Make a matrix that use random value Constant
Combined_B = matrix(runif(4*n,-1,1),n,4)
i=1
registerDoParallel(cores=detectCores())
system.time(
# Save the final score in combined score
Combined_score <- foreach (i= 1:n,.combine = 'rbind') %:%
foreach (i2= 1:5,.combine = 'c') %dopar% {
play(i,i2,init,Combined_B[i,],CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
}
)

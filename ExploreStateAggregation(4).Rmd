---
title: "BayesMDP"
author: "Monkie"
date: "11/26/2019"
output: pdf_document
---

In this section we simulate a similar situation as the Datafenerator(2) for MDP, where we are not using a = BX formulation but instead MDP Value Iteration approach.

In this program we generate more data for the CARTPOLE problem GIVEN BAYES OUTPUT AND initial input
```{r}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("DATA/data.csv")[,-1]
```

Load all the data that we already have made and just do POMDP now on.
```{r}
Splitstate = 10
dirname = paste0("Bayes",Splitstate,"s")
if (dir.exists(dirname)){
  
k=paste0(dirname,"/a2xPOS")

assign("CartPositionQuantile",read.csv(paste0(k,"_CartPositionQuantile.csv"), stringsAsFactors=FALSE))
rowname = CartPositionQuantile[,1]
rownames(CartPositionQuantile) <-rowname
CartPositionQuantile = CartPositionQuantile[, -1]
assign("CartVelQuantile",read.csv(paste0(k,"_CartVelQuantile.csv"),row.names = rowname)[,-1])
assign("PoleAngleQuantile",read.csv(paste0(k,"_PoleAngleQuantile.csv"),row.names = rowname)[,-1])
assign("PoleVelocityQuantile",read.csv(paste0(k,"_PoleVelocityQuantile.csv"),row.names = rowname)[,-1])
assign("ExpectedRew",read.csv(paste0(k,"_Reward.csv"))[,-1])
assign("policy",read.csv(paste0(k,"_policy.csv"))[,-1])
assign("T0",as.matrix(read.csv(paste0(k,"_Transition0.csv"))[,-1]))
assign("T1",as.matrix(read.csv(paste0(k,"_Transition1.csv"))[,-1]))

} else {
  cat(paste0("ERROR ::: DIRECTORY ---",dirname,"--- DOES NOT EXIST !!!\n"))
}
```


Read Bayes generated data
```{r}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
  assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
  assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
assign("EstimatedAngle", as.matrix(read.csv(paste0(bayesdir,"/BayesPOMDPangle.csv"))[,-1]))# 20000 by 4
```

Create the relationship between the Observation and the States
```{r}

n_set = 1000
n_var = dim(EstimatedAngle)[2]
angle_i_state = matrix(0,Splitstate,Splitstate^(n_var-1))
for (i in 1:Splitstate){
  cartvel_i = runif(n_set,CartVelQuantile[i],CartVelQuantile[i+1])
  cartpos_i = runif(n_set,CartPositionQuantile[i],CartPositionQuantile[i+1])
  polevel_i = runif(n_set,PoleVelocityQuantile[i],PoleVelocityQuantile[i+1])
  angle_mat = matrix(c(cartpos_i,cartvel_i,polevel_i,rep(1,n_set)),n_set,n_var) # 1000 by 4
  angle_i_dist = c(EstimatedAngle %*% t(angle_mat))
  angle_i_state 
  <- foreach (i2= 1:Splitstate,.combine = 'c') %do% {
    sum()
  }
}

```



MAP variable to States and also Transition function for each actions.
```{r setup, include=FALSE}

action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
    j = sample(1:20000, 1)
    state[1] = state[1] + sum(ChgCarPos0[j,] * state )
    state[2] = state[2] + sum(ChgCarVel0[j,] * state )
    state[3] = state[3] + sum(ChgPolAng0[j,] * state )
    state[4] = state[4] + sum(ChgPolVel0[j,] * state )
    
    return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
    j = sample(1:20000, 1)
    state[1] = state[1] + sum(ChgCarPos1[j,] * state )
    state[2] = state[2] + sum(ChgCarVel1[j,] * state )
    state[3] = state[3] + sum(ChgPolAng1[j,] * state )
    state[4] = state[4] + sum(ChgPolVel1[j,] * state )
    return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
  i=sum(CartPosQuantile[1:level] <= CartPos)
  if(i==0){i=1}
  j=sum(CartVelQuantile[1:level] <= CartVel)
  if(j==0){j=1}
  k=sum(PoleAngleQuantile[1:level] <= PoleAng)
  if(k==0){k=1}
  l=sum(PoleVelocityQuantile[1:level] <= PoleVel)
  if(l==0){l=1}
  return((level*level*level*(i-1) + level*level*(j-1) + level*(k-1) +(l-1))+1)
}

V2S = as.data.frame(matrix(0,Splitstate^3,5))
colnames(V2S) = c("CartPosQuantile","CartVelQuantile","PoleAngleQuantile","PoleVelocityQuantile","State")
index = 0
for (i in 1:1){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
  index = index + 1
  V2S$CartPosQuantile[index] = i
  V2S$CartVelQuantile[index] = j
  V2S$PoleAngleQuantile[index] = k
  V2S$PoleVelocityQuantile[index] = l
  V2S$State[index] = var2state(Splitstate,CartPosQuantile[i],CartVelQuantile[j],PoleAngleQuantile[k],PoleVelocityQuantile[l],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
}}}}

```




```{r}
temprew  = CondtionAngle/abs(PoleAngleQuantile) #-abs(CartPosQuantile) 
temprew = temprew[-which(temprew==Inf)]

ExpectedRew = rep(0,(totalstate/Splitstate))
for (i in 1:Splitstate){
ExpectedRew[which(V2S$PoleAngleQuantile==i)] = temprew[i]
}
```

MDP 
```{r}
discount = 0.95
v = rep(0,(totalstate/Splitstate))

for (n in 1:100){
  v  =pmax(T0 %*%(ExpectedRew + discount* v), T1 %*%(ExpectedRew +  discount*  v))
}

result= (T0 %*%(ExpectedRew + v))>(T1 %*%(ExpectedRew +  v))

```


Quantile aggregation outperform even spaacing state aggregation.
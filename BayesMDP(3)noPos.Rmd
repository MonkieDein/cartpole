---
title: "BayesMDP"
author: "Monkie"
date: "11/26/2019"
output: pdf_document
---

In this section we simulate a similar situation as the Datafenerator(2) for MDP, where we are not using a = BX formulation but instead MDP Value Iteration approach.

In this program we generate more data for the CARTPOLE problem GIVEN BAYES OUTPUT AND initial input
```{r}
library(gsubfn)
library(doParallel)
library(foreach)
rm(list = ls())
# setwd("~/Desktop/AML/cartpole")
setwd("~/Desktop/GITHUB/cartpole/cartpole")
df = read.csv("DATA/data.csv")[,-1]

# df = read.csv("cartpole50.csv")
# source("csvfunction.R")
# df = CreateSym(df)
```

```{r}
# summary(df)
Splitstate = 20
# summary(df)

# MAKE QUANTILE
CartPosQuantile  = quantile(df$CartPos,(0:(Splitstate))*(1/Splitstate))
CartVelQuantile  = quantile(df$CartVelocity,(0:(Splitstate))*(1/Splitstate))
PoleAngleQuantile  = quantile(df$PoleAngle,(0:(Splitstate))*(1/Splitstate))
PoleVelocityQuantile  = quantile(df$PoleVelocity,(0:(Splitstate))*(1/Splitstate))

```


```{r}
# r = range(df$CartPos)
# CartPosQuantile  = (0:(Splitstate))*(1/Splitstate)*(r[2]-r[1])+r[1]
# r = range(df$CartVelocity)
# CartVelQuantile  = (0:(Splitstate))*(1/Splitstate)*(r[2]-r[1])+r[1]
# r = range(df$PoleAngle)
# PoleAngleQuantile  = (0:(Splitstate))*(1/Splitstate)*(r[2]-r[1])+r[1]
# r = range(df$PoleVelocity)
# PoleVelocityQuantile  = (0:(Splitstate))*(1/Splitstate)*(r[2]-r[1])+r[1]

```

Make a condition such that it is the smallest angle that we have seen but not losing.
```{r}
# GAME OVER CONDITION
CondtionAngle = min(df$PoleAngle[which(df$Reward!=1&df$PoleAngle>0)])*0.96
```




```{r setup, include=FALSE}

action0 <- function(state,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0){
    j = sample(1:20000, 1)
    state[1] = state[1] + sum(ChgCarPos0[j,] * state )
    state[2] = state[2] + sum(ChgCarVel0[j,] * state )
    state[3] = state[3] + sum(ChgPolAng0[j,] * state )
    state[4] = state[4] + sum(ChgPolVel0[j,] * state )
    
    return(state[1:4])
}
action1 <- function(state,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1){
    j = sample(1:20000, 1)
    state[1] = state[1] + sum(ChgCarPos1[j,] * state )
    state[2] = state[2] + sum(ChgCarVel1[j,] * state )
    state[3] = state[3] + sum(ChgPolAng1[j,] * state )
    state[4] = state[4] + sum(ChgPolVel1[j,] * state )
    return(state[1:4])
}
#Estimate everything has even level
var2state <- function(level,CartPos,CartVel,PoleAng,PoleVel,CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile){
  i=sum(CartPosQuantile[1:level] <= CartPos)
  if(i==0){i=1}
  j=sum(CartVelQuantile[1:level] <= CartVel)
  if(j==0){j=1}
  k=sum(PoleAngleQuantile[1:level] <= PoleAng)
  if(k==0){k=1}
  l=sum(PoleVelocityQuantile[1:level] <= PoleVel)
  if(l==0){l=1}
  return((level*level*level*(i-1) + level*level*(j-1) + level*(k-1) +(l-1))+1)
}

V2S = as.data.frame(matrix(0,Splitstate^3,5))
colnames(V2S) = c("CartPosQuantile","CartVelQuantile","PoleAngleQuantile","PoleVelocityQuantile","State")
index = 0
for (i in 1:1){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
  index = index + 1
  V2S$CartPosQuantile[index] = i
  V2S$CartVelQuantile[index] = j
  V2S$PoleAngleQuantile[index] = k
  V2S$PoleVelocityQuantile[index] = l
  V2S$State[index] = var2state(Splitstate,CartPosQuantile[i],CartVelQuantile[j],PoleAngleQuantile[k],PoleVelocityQuantile[l],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
}}}}

```


Read Bayes generated data
```{r}
bayesdir = "BayesMLR-V1"
for (i in 12:15)  {
  assign(paste0(colnames(df)[i],"0"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit0.csv"))[,-1])
  assign(paste0(colnames(df)[i],"1"), read.csv(paste0(bayesdir,"/",colnames(df)[i],"BayesFit1.csv"))[,-1])
}
```



```{r}
registerDoParallel(cores=detectCores())

# TOtal state space
totalstate = Splitstate^4

# Iteration for each state space
iteration = 100
# Run for loop to generate data
# Combined_score <- foreach (i2= 1:iteration,.combine = 'cbind') %:% 
#   foreach (i= 1:Splitstate,.combine = 'c') %:% 
#   foreach (j= 1:Splitstate,.combine = 'c') %:% 
#   foreach (k= 1:Splitstate,.combine = 'c') %:% 
#   foreach (l= 1:Splitstate,.combine = 'c') %dopar% {
#     start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
#     state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
#     var2state(Splitstate,state[1],state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)summary(rowSums(T0))
#      
#   }
FixPosition = min(CartPosQuantile)

info = rep(0,(totalstate/Splitstate))
Combined_score0 <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
  count = 0
  for (i in 1:1){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
  count = count+1
  start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
  state = action0(start,CondtionAngle,ChgCarPos0,ChgCarVel0,ChgPolAng0,ChgPolVel0)
  futurestate = var2state(Splitstate,FixPosition,state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
  info[count] = futurestate
  }}}}
  info
}

Combined_score1 <- foreach (i2= 1:iteration,.combine = 'cbind') %dopar% {
  count = 0
  for (i in 1:1){for (j in 1:Splitstate){for (k in 1:Splitstate){for (l in 1:Splitstate){
  count = count+1
  start = c(runif(1,CartPosQuantile[i],CartPosQuantile[i+1]), runif(1,CartVelQuantile[j],CartVelQuantile[j+1]) ,runif(1,PoleAngleQuantile[k],PoleAngleQuantile[k+1]) , runif(1,PoleVelocityQuantile[l],PoleVelocityQuantile[l+1]),1 )
  state = action1(start,CondtionAngle,ChgCarPos1,ChgCarVel1,ChgPolAng1,ChgPolVel1)
  futurestate = var2state(Splitstate,FixPosition,state[2],state[3],state[4],CartPosQuantile,CartVelQuantile,PoleAngleQuantile,PoleVelocityQuantile)
  info[count] = futurestate
  }}}}
  info
}

registerDoParallel(cores=1)
stopImplicitCluster()

```
Turn combined_score to Transition Matrix
```{r}
T0 = matrix(0,(totalstate/Splitstate),(totalstate/Splitstate))

T1 = matrix(0,(totalstate/Splitstate),(totalstate/Splitstate))

list[ROW,COL]=dim(Combined_score0)
for (i in 1:ROW){
  for (j in 1:COL){
    T0[i,Combined_score0[i,j]] =T0[i,Combined_score0[i,j]]+0.01
    T1[i,Combined_score1[i,j]] =T1[i,Combined_score1[i,j]]+0.01
  }
}
# T0  = T0 / rowSums(T0)[1]
summary(rowSums(T0))
# which(rowSums(T0) > 0)
# which(colSums(T0) > 0)
```

```{r}
temprew  = CondtionAngle/abs(PoleAngleQuantile) #-abs(CartPosQuantile) 
temprew = temprew[-which(temprew==Inf)]

ExpectedRew = rep(0,(totalstate/Splitstate))
for (i in 1:Splitstate){
ExpectedRew[which(V2S$PoleAngleQuantile==i)] = temprew[i]
}
```

MDP 
```{r}
discount = 0.95
v = rep(0,(totalstate/Splitstate))

for (n in 1:100){
  v  =pmax(T0 %*%(ExpectedRew + discount* v), T1 %*%(ExpectedRew +  discount*  v))
}

result= (T0 %*%(ExpectedRew + v))>(T1 %*%(ExpectedRew +  v))

```



a is used as the even spacing states.
a2 is used as the quantile spacing states.

```{r}
dirname = paste0("Bayes",Splitstate,"s")
if (!dir.exists(dirname)){
  dir.create(dirname)
}
k=paste0(dirname,"/a2xPOS")
if (TRUE){
  write.csv(CartPosQuantile[-Splitstate],paste0(k,"_CartPositionQuantile.csv"))
  write.csv(CartVelQuantile[-Splitstate],paste0(k,"_CartVelQuantile.csv"))
  write.csv(PoleAngleQuantile[-Splitstate],paste0(k,"_PoleAngleQuantile.csv"))
  write.csv(PoleVelocityQuantile[-Splitstate],paste0(k,"_PoleVelocityQuantile.csv"))
  write.csv(1:(totalstate/Splitstate),paste0(k,"_StateMap.csv"))
  write.csv(1:(totalstate/Splitstate),paste0(k,"_StateArr.csv"))
  write.csv(ExpectedRew,paste0(k,"_Reward.csv"))
  write.csv(as.numeric(result),paste0(k,"_policy.csv"))
  # write.csv(T0,paste0(k,"_Transition0.csv"))
  # write.csv(T1,paste0(k,"_Transition1.csv"))
}
```

Quantile aggregation outperform even spaacing state aggregation.